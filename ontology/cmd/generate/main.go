package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	defaultOutFile = "ontology/generated.ttl"
	skillSphereNS  = "https://ontology.skillsphere.dev/schema#"
)

func main() {
	var (
		descriptorPath = flag.String("descriptor", "", "path to an existing FileDescriptorSet (optional)")
		modulePath     = flag.String("module-path", ".", "path to the Buf module (if descriptor is not provided)")
		outPath        = flag.String("out", defaultOutFile, "output TTL file path")
	)
	flag.Parse()

	data, err := loadDescriptor(*descriptorPath, *modulePath)
	if err != nil {
		die(err)
	}

	var set descriptorpb.FileDescriptorSet
	if err := proto.Unmarshal(data, &set); err != nil {
		die(fmt.Errorf("unmarshal descriptor set: %w", err))
	}

	enums := collectEnums(&set)
	if len(enums) == 0 {
		die(errors.New("no enums found in descriptor set"))
	}

	var buf bytes.Buffer
	writeHeader(&buf)
	for _, enum := range enums {
		writeEnum(&buf, enum)
	}

	if err := os.MkdirAll(filepath.Dir(*outPath), 0o755); err != nil {
		die(fmt.Errorf("create output directory: %w", err))
	}
	if err := os.WriteFile(*outPath, buf.Bytes(), 0o644); err != nil {
		die(fmt.Errorf("write file: %w", err))
	}
}

func loadDescriptor(descriptorPath, modulePath string) ([]byte, error) {
	if descriptorPath != "" {
		return os.ReadFile(descriptorPath)
	}

	cmd := exec.Command("buf", "build", "-o", "-")
	cmd.Dir = modulePath
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr
	if err := cmd.Run(); err != nil {
		if stderr.Len() > 0 {
			return nil, fmt.Errorf("buf build failed: %s", strings.TrimSpace(stderr.String()))
		}
		return nil, fmt.Errorf("buf build failed: %w", err)
	}
	return stdout.Bytes(), nil
}

type enumInfo struct {
	Name   string
	Values []enumValue
	File   string
}

type enumValue struct {
	Name        string
	PrefLabel   string
	Notation    string
	ConceptName string
}

func collectEnums(set *descriptorpb.FileDescriptorSet) []enumInfo {
	var enums []enumInfo
	for _, file := range set.GetFile() {
		for _, enum := range file.GetEnumType() {
			enums = append(enums, buildEnumInfo(file.GetName(), enum))
		}
	}
	return enums
}

func buildEnumInfo(fileName string, enum *descriptorpb.EnumDescriptorProto) enumInfo {
	enumName := enum.GetName()
	enumPrefix := camelToScreamingSnake(enumName)
	var values []enumValue
	for _, v := range enum.GetValue() {
		name := v.GetName()
		if strings.HasSuffix(name, "_UNSPECIFIED") {
			continue
		}
		raw := strings.TrimPrefix(name, enumPrefix+"_")
		values = append(values, enumValue{
			Name:        name,
			PrefLabel:   toTitle(raw),
			Notation:    name,
			ConceptName: fmt.Sprintf("sk:%s%s", enumName, snakeToPascal(raw)),
		})
	}
	return enumInfo{
		Name:   enumName,
		File:   fileName,
		Values: values,
	}
}

func writeHeader(buf *bytes.Buffer) {
	buf.WriteString("# Code generated by ontology/cmd/generate; DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("@prefix sk: <%s> .\n", skillSphereNS))
	buf.WriteString("@prefix skos: <http://www.w3.org/2004/02/skos/core#> .\n")
	buf.WriteString("@prefix owl: <http://www.w3.org/2002/07/owl#> .\n")
	buf.WriteString("@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .\n\n")
}

func writeEnum(buf *bytes.Buffer, enum enumInfo) {
	if len(enum.Values) == 0 {
		return
	}
	buf.WriteString(fmt.Sprintf("# %s (%s)\n", enum.Name, enum.File))
	buf.WriteString(fmt.Sprintf("sk:%sConcept a owl:Class ;\n", enum.Name))
	buf.WriteString("  rdfs:subClassOf skos:Concept .\n\n")

	buf.WriteString(fmt.Sprintf("sk:%sScheme a skos:ConceptScheme ;\n", enum.Name))
	buf.WriteString(fmt.Sprintf("  rdfs:label \"%s\" .\n\n", splitCamel(enum.Name)))

	for _, value := range enum.Values {
		buf.WriteString(fmt.Sprintf("%s a sk:%sConcept , skos:Concept ;\n", value.ConceptName, enum.Name))
		buf.WriteString(fmt.Sprintf("  skos:prefLabel \"%s\" ;\n", value.PrefLabel))
		buf.WriteString(fmt.Sprintf("  skos:notation \"%s\" ;\n", value.Notation))
		buf.WriteString(fmt.Sprintf("  skos:inScheme sk:%sScheme .\n\n", enum.Name))
	}
}

func camelToScreamingSnake(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && isUpper(r) && (i+1 < len(s) && !isUpper(rune(s[i+1]))) {
			result = append(result, '_')
		} else if i > 0 && isUpper(r) && isLower(rune(s[i-1])) {
			result = append(result, '_')
		}
		result = append(result, toUpper(r))
	}
	return string(result)
}

func snakeToPascal(s string) string {
	parts := strings.Split(strings.ToLower(s), "_")
	for i, part := range parts {
		if part == "" {
			continue
		}
		parts[i] = strings.ToUpper(part[:1]) + part[1:]
	}
	return strings.Join(parts, "")
}

func splitCamel(s string) string {
	var parts []string
	var current strings.Builder
	for i, r := range s {
		if i > 0 && isUpper(r) && (i+1 < len(s) && !isUpper(rune(s[i+1]))) {
			parts = append(parts, current.String())
			current.Reset()
		}
		current.WriteRune(r)
	}
	if current.Len() > 0 {
		parts = append(parts, current.String())
	}
	return strings.Join(parts, " ")
}

func toTitle(s string) string {
	s = strings.ToLower(s)
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if part == "" {
			continue
		}
		parts[i] = strings.ToUpper(part[:1]) + part[1:]
	}
	return strings.Join(parts, " ")
}

func isUpper(r rune) bool {
	return r >= 'A' && r <= 'Z'
}

func isLower(r rune) bool {
	return r >= 'a' && r <= 'z'
}

func toUpper(r rune) rune {
	if isLower(r) {
		return r - ('a' - 'A')
	}
	return r
}

func die(err error) {
	fmt.Fprintln(os.Stderr, err)
	os.Exit(1)
}
